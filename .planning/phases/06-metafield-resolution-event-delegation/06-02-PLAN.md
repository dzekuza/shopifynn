---
phase: 06-metafield-resolution-event-delegation
plan: 02
type: execute
wave: 2
depends_on:
  - 06-01
files_modified:
  - assets/configurator.js
autonomous: true
requirements:
  - CONF-04

must_haves:
  truths:
    - "_calculateLineItems() exists and returns an array of line item objects"
    - "_updatePrice() calls _calculateLineItems() to compute the total — does not independently walk state"
    - "_buildCartItems() calls _calculateLineItems() to build cart payload — does not independently walk state"
    - "Display price and cart total always match for any configuration combination"
  artifacts:
    - path: "assets/configurator.js"
      provides: "Unified _calculateLineItems() method"
      contains: "_calculateLineItems"
  key_links:
    - from: "assets/configurator.js _updatePrice()"
      to: "_calculateLineItems()"
      via: "method call"
      pattern: "this\\._calculateLineItems\\(\\)"
    - from: "assets/configurator.js _buildCartItems()"
      to: "_calculateLineItems()"
      via: "method call"
      pattern: "this\\._calculateLineItems\\(\\)"
---

<objective>
Extract a single `_calculateLineItems()` method that serves as the source of truth for both price display and cart payload, eliminating the risk of price drift between what's shown and what's charged.

Purpose: Two independent price calculation paths (_updatePrice walking state for display, _buildCartItems walking state for cart) can drift when add-ons are added or pricing logic changes. A single shared method guarantees consistency.
Output: Updated assets/configurator.js with _calculateLineItems() called by both _updatePrice() and _buildCartItems().
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-metafield-resolution-event-delegation/06-RESEARCH.md
@.planning/phases/06-metafield-resolution-event-delegation/06-01-SUMMARY.md
@assets/configurator.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create _calculateLineItems() and rewire _updatePrice() and _buildCartItems()</name>
  <files>assets/configurator.js</files>
  <action>
Create a single `_calculateLineItems()` method in the PRICE CALCULATION section (section 6) that returns an array of line item objects. Each item has: `{ variantId, quantity, price, label, properties }`.

**Build _calculateLineItems() by unifying the logic from _updatePrice() and _buildCartItems():**

The method must cover all 15 line item categories in the same order:

1. **Base product** — `this.state.baseVariantId`, qty 1, price `this.state.basePrice || 0`, properties `{ '_config': 'base' }`
2. **Liner** — resolve variant price from `this.data.liners` using `this.state.liner` + `this.state.linerVariant`, properties `{ '_config': 'liner' }`
3. **Insulation** — if `this.state.insulation`, first product in `this.data.insulations`, properties `{ '_config': 'insulation' }`
4. **Glass door** — if `this.state.glassDoor`, find addon in `this.data.oven_addons` by title containing 'glass', properties `{ '_config': 'oven-addon' }`
5. **Chimney** — if `this.state.chimney`, find addon by title containing 'chimney', properties `{ '_config': 'oven-addon' }`
6. **Exterior** — resolve from `this.data.exteriors` using `this.state.exterior` + `this.state.exteriorVariant`, properties `{ '_config': 'exterior' }`
7. **Hydro** — if `this.state.hydro`, find in `this.data.hydro`, properties `{ '_config': 'hydro', 'Nozzles': String(this.state.hydroNozzles) }`
8. **Air** — if `this.state.air`, find in `this.data.air`, properties `{ '_config': 'air', 'Nozzles': String(this.state.airNozzles) }`
9. **Filter** — if `this.state.filterEnabled && this.state.filterProduct`, find in `this.data.filters`, properties `{ '_config': 'filter' }`
10. **LED** — if `this.state.led`, find in `this.data.leds`, qty `this.state.ledQty || 1`, properties `{ '_config': 'led' }`
11. **Thermometer** — if `this.state.thermometer`, find in `this.data.thermometers`, properties `{ '_config': 'thermometer' }`
12. **Stairs** — if `this.state.stairs`, first product in `this.data.stairs`, properties `{ '_config': 'stairs' }`
13. **Pillows** — if `this.state.pillows`, first product in `this.data.pillows`, qty `this.state.pillowQty || 2`, properties `{ '_config': 'pillows' }`
14. **Cover** — resolve from `this.data.covers` using `this.state.cover` + `this.state.coverVariant`, properties `{ '_config': 'cover' }`
15. **Heater connection** — if `this.state.heaterConnection === '90-degree'`, use `this.data.heater_90`, properties `{ '_config': 'heater-connection' }`

Each item must include both the `variantId` (for cart) and `price` (for display total). Use the variant's price when a variant is resolved, otherwise the product's price. Only push items with valid variantId (skip items where the product or variant lookup fails).

**Rewire _updatePrice():**

Replace the manual price accumulation with:

```javascript
_updatePrice() {
  const items = this._calculateLineItems();
  const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);

  // Update display (keep existing DOM update logic)
  const formatted = money(total);
  const hasSize = !!this.state.size;
  if (this.totalPriceEl) {
    this.totalPriceEl.textContent = formatted;
    this.totalPriceEl.style.visibility = hasSize ? 'visible' : 'hidden';
  }
  if (this.stickyPrice) {
    this.stickyPrice.textContent = formatted;
  }
  if (this.stickyBar) {
    this.stickyBar.style.display = hasSize ? '' : 'none';
  }

  this._currentTotal = total;
  this._updateSummary();
}
```

Delete all the individual `_getSelectedVariantPrice`, `_getProductPrice`, `_getSelectedProductPrice`, `_getAddonPrice` helper methods ONLY if they are no longer called anywhere else. If they are still used by other methods (e.g., _updateSummary), keep them. Check all call sites before deleting.

**Rewire _buildCartItems():**

Replace the manual state walking with:

```javascript
_buildCartItems() {
  const configSummary = this._buildConfigSummary();
  return this._calculateLineItems()
    .filter(item => item.variantId)
    .map((item, i) => ({
      id: item.variantId,
      quantity: item.quantity,
      properties: i === 0
        ? { ...item.properties, 'Configuration': configSummary }
        : item.properties,
    }));
}
```

**IMPORTANT:** The `'Configuration': configSummary` property MUST only be added to the first (base) item — this is special-cased in _buildCartItems, NOT in _calculateLineItems. The shared method returns raw data; _buildCartItems adds the summary post-processing.
  </action>
  <verify>
Verify `_calculateLineItems` method exists in configurator.js.
Verify `_updatePrice` calls `this._calculateLineItems()` — no manual price accumulation.
Verify `_buildCartItems` calls `this._calculateLineItems()` — no manual state walking.
Verify _buildCartItems still adds 'Configuration' property to first item only.
Count line items returned by _calculateLineItems — should cover all 15 categories.
  </verify>
  <done>
_calculateLineItems() is the single source of truth for line item computation. _updatePrice() sums its output for display. _buildCartItems() maps its output for cart payload. Both callers consume the same data — price drift between display and cart is structurally impossible.
  </done>
</task>

</tasks>

<verification>
1. `grep -c '_calculateLineItems' assets/configurator.js` returns at least 3 (definition + 2 callers)
2. `_updatePrice()` contains `this._calculateLineItems()` call and no manual price accumulation per-item
3. `_buildCartItems()` contains `this._calculateLineItems()` call and no manual state walking per-item
4. `'Configuration': configSummary` appears only in _buildCartItems, not in _calculateLineItems
5. All 15 line item categories are covered in _calculateLineItems
</verification>

<success_criteria>
- A single _calculateLineItems() method is the source of truth for both price display and cart payload
- _updatePrice() computes total from _calculateLineItems() output — no independent state walking
- _buildCartItems() builds cart items from _calculateLineItems() output — no independent state walking
- Configuration summary property is correctly attached to base item only
- No existing functionality is broken — all add-on types still resolve correctly
</success_criteria>

<output>
After completion, create `.planning/phases/06-metafield-resolution-event-delegation/06-02-SUMMARY.md`
</output>
