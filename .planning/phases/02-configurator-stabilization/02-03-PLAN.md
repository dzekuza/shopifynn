---
phase: 02-configurator-stabilization
plan: 03
type: execute
wave: 2
depends_on:
  - "02-02"
files_modified:
  - assets/configurator.js
autonomous: true
requirements:
  - CONF-04
  - CONF-07
  - CONF-08

must_haves:
  truths:
    - "The price displayed in the configurator and the cart total match exactly for any configuration"
    - "Clicking between products in a step does not accumulate duplicate event listeners"
    - "Currency formatting respects the store's locale setting, not a hardcoded de-DE"
  artifacts:
    - path: "assets/configurator.js"
      provides: "Unified price calculation, event delegation fix, locale-aware formatting"
      contains: "_calculateLineItems"
  key_links:
    - from: "assets/configurator.js _calculateLineItems()"
      to: "assets/configurator.js _updatePrice()"
      via: "_updatePrice calls _calculateLineItems to get display total"
      pattern: "_calculateLineItems"
    - from: "assets/configurator.js _calculateLineItems()"
      to: "assets/configurator.js _buildCartItems()"
      via: "_buildCartItems calls _calculateLineItems for cart payload"
      pattern: "_calculateLineItems"
    - from: "layout/theme.liquid window.__shopLocale"
      to: "assets/configurator.js money()"
      via: "money() reads window.__shopLocale for Intl.NumberFormat locale"
      pattern: "window\\.__shopLocale"
---

<objective>
Unify the two separate price calculation paths into a single _calculateLineItems() source of truth, fix event listener accumulation in variant selection, and replace hardcoded de-DE locale with the store's actual locale.

Purpose: Display price and cart price currently diverge because they're calculated independently. Event listeners accumulate on every product click. Currency shows as German format regardless of store locale.
Output: Refactored `configurator.js` with unified pricing, clean event delegation, and locale-aware formatting.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-configurator-stabilization/02-RESEARCH.md
@.planning/phases/02-configurator-stabilization/02-02-SUMMARY.md

@assets/configurator.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Unify price calculation into _calculateLineItems()</name>
  <files>assets/configurator.js</files>
  <action>
1. Read `assets/configurator.js` and locate both `_updatePrice()` and `_buildCartItems()` methods.

2. Create a new method `_calculateLineItems()` that returns an array of line item objects:
```javascript
_calculateLineItems() {
  const items = [];
  // Base product variant
  if (this.state.baseVariantId) {
    items.push({
      variantId: this.state.baseVariantId,
      quantity: 1,
      priceInCents: this.state.basePrice,
      label: this.state.selectedTier?.title || 'Base'
    });
  }
  // Each add-on that has been selected follows the same pattern:
  // Check state for the add-on's variant ID and price, push if present
  // ... (replicate the logic currently split between _updatePrice and _buildCartItems)
  return items;
}
```

The exact add-on fields to include depend on the current state shape — read both `_updatePrice()` and `_buildCartItems()` to identify ALL price components they currently track. The new method must cover the UNION of both — if one path includes an add-on the other doesn't, include it.

3. Refactor `_updatePrice()` to consume `_calculateLineItems()`:
```javascript
_updatePrice() {
  const items = this._calculateLineItems();
  const total = items.reduce((sum, i) => sum + i.priceInCents * i.quantity, 0);
  if (this.totalPriceEl) this.totalPriceEl.textContent = money(total);
  // Keep any existing running-total or per-step price display logic
}
```

4. Refactor `_buildCartItems()` to consume `_calculateLineItems()`:
```javascript
_buildCartItems() {
  return this._calculateLineItems()
    .filter(i => i.variantId)
    .map(i => ({
      id: i.variantId,
      quantity: i.quantity,
      properties: i.properties || {}
    }));
}
```

5. Verify that after refactoring, no price calculation logic remains outside `_calculateLineItems()`. Both `_updatePrice()` and `_buildCartItems()` should be pure consumers.

IMPORTANT: Preserve ALL existing add-on types. Do not drop any price component that was in either of the original methods. The goal is unification, not simplification.
  </action>
  <verify>
- Grep for `_calculateLineItems` — method exists and is called by both `_updatePrice` and `_buildCartItems`
- Grep for price calculation patterns outside `_calculateLineItems` — none should exist (no `this.state.basePrice` arithmetic in `_updatePrice` or `_buildCartItems` directly)
- The method returns an array of objects with `variantId`, `quantity`, `priceInCents`, `label` fields
  </verify>
  <done>A single _calculateLineItems() method is the sole source of truth for both display and cart pricing. Display total and cart total always match.</done>
</task>

<task type="auto">
  <name>Task 2: Fix event delegation and locale formatting</name>
  <files>assets/configurator.js</files>
  <action>
**Event delegation fix (CONF-07):**

1. Locate `_showVariants()` method. Find the line where it attaches a new click listener to a swatch/variant container (`target.addEventListener('click', ...)`). This listener fires on every product selection, accumulating handlers.

2. Remove the `addEventListener` call from `_showVariants()`.

3. In `_bindEvents()`, add a case to the existing top-level click delegation handler for variant/swatch selection:
```javascript
case 'select-variant': {
  this._handleVariantSelect(
    target.dataset.group,
    parseInt(target.dataset.variantId),
    parseInt(target.dataset.price)
  );
  break;
}
```

4. If `_handleVariantSelect` doesn't exist yet, extract the variant selection logic from the old inline listener into this new method. It should update state with the selected variant ID and price, then call `_updatePrice()`.

5. Ensure the variant/swatch buttons rendered by `_showVariants()` use `data-action="select-variant"` along with `data-group`, `data-variant-id`, and `data-price` attributes so the delegated handler can pick them up.

**Locale formatting fix (CONF-08):**

6. Locate the `money()` function (approximately line 14 per research). It currently hardcodes `'de-DE'`.

7. Replace it with:
```javascript
function money(cents) {
  const locale = window.__shopLocale || 'de-DE';
  const currency = window.__shopCurrency || 'EUR';
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(cents / 100);
}
```

This reads `window.__shopLocale` which was injected by Plan 01 (Task 2) in `layout/theme.liquid`. The `'de-DE'` fallback ensures backward compatibility if the variable isn't available.
  </action>
  <verify>
- Grep `_showVariants` for `addEventListener` — should NOT contain any `addEventListener('click'` calls
- Grep `_bindEvents` for `select-variant` — the delegated case must exist
- Grep `money` function for `window.__shopLocale` — must reference the locale variable
- Grep for hardcoded `'de-DE'` in money function — should only appear as fallback default, not as the primary locale
  </verify>
  <done>No event listener accumulation on variant clicks. Currency format uses the store's locale. Both fixes are clean and backward-compatible.</done>
</task>

</tasks>

<verification>
1. Select different products in the same step multiple times — price should update correctly without doubling or flickering (confirms no listener accumulation)
2. Complete a full 15-step configuration — displayed total must match the sum of all selected item prices
3. Add to cart — cart line items must have the same total as displayed in the configurator
4. Currency displays in the correct locale format (e.g., EUR symbol placement matches store locale)
</verification>

<success_criteria>
- Single _calculateLineItems() method used by both display and cart
- No addEventListener calls inside _showVariants()
- money() function reads window.__shopLocale with de-DE fallback
- Price display and cart total always agree
</success_criteria>

<output>
After completion, create `.planning/phases/02-configurator-stabilization/02-03-SUMMARY.md`
</output>
