---
phase: 07-price-unification-locale-formatting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - assets/configurator.js
autonomous: true
requirements:
  - CONF-04
  - CONF-07
  - CONF-08

must_haves:
  truths:
    - "money() formats currency using the shop's locale and currency from window.__shopLocale/window.__shopCurrency — not hardcoded de-DE/EUR"
    - "Selecting a product multiple times in the same step does not accumulate duplicate event listeners"
    - "Gallery thumbnail clicks after model switch show the correct model's images"
    - "Re-visiting a configurator step and re-selecting an option fires the selection handler exactly once — no duplicate firings from accumulated listeners"
    - "The displayed configuration total and the cart line item total match exactly for any combination of model, size, and add-ons"
  artifacts:
    - path: "assets/configurator.js"
      provides: "Locale-aware money(), _calculateLineItems() source of truth, and fully delegated event handling"
      contains: "Intl.NumberFormat, _calculateLineItems"
  key_links:
    - from: "money()"
      to: "window.__shopLocale, window.__shopCurrency"
      via: "Intl.NumberFormat constructor"
      pattern: "Intl\\.NumberFormat\\(.*__shopLocale"
    - from: "_bindEvents() switch"
      to: "select-variant, select-thumb, edit-summary-step"
      via: "data-action delegation cases"
      pattern: "case 'select-variant'"
    - from: "_updatePrice()"
      to: "_calculateLineItems()"
      via: "shared line items computation"
      pattern: "_calculateLineItems\\(\\)"
    - from: "_buildCartItems()"
      to: "_calculateLineItems()"
      via: "shared line items computation"
      pattern: "_calculateLineItems\\(\\)"
---

<objective>
Fix locale-aware currency formatting, consolidate price calculation into a single source of truth, and eliminate accumulating per-element event listeners in configurator.js.

Purpose: CONF-08 — money() hardcodes 'de-DE' locale and '€' symbol, ignoring the shop's actual locale/currency injected in theme.liquid. CONF-04 — _updatePrice() and _buildCartItems() independently walk state to compute prices, risking display/cart drift; a single _calculateLineItems() function should serve both. CONF-07 — _showVariants() and _updateGallery() attach new listeners on every re-render, accumulating duplicates that cause multiple handler firings and wasted DOM updates.

Output: configurator.js with Intl.NumberFormat-based money(), shared _calculateLineItems() driving both display and cart, and all dynamic interactions routed through _bindEvents() delegation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-price-unification-locale-formatting/07-RESEARCH.md
@assets/configurator.js
@layout/theme.liquid
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite money() to use Intl.NumberFormat with shop locale/currency globals</name>
  <files>assets/configurator.js</files>
  <action>
Replace the money() function (lines 14-17) with an Intl.NumberFormat-based implementation:

BEFORE:
```javascript
function money(cents) {
  const val = (cents / 100).toLocaleString('de-DE', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  return '€' + val;
}
```

AFTER:
```javascript
function money(cents) {
  const locale = window.__shopLocale || 'de-DE';
  const currency = window.__shopCurrency || 'EUR';
  return new Intl.NumberFormat(locale, {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(cents / 100);
}
```

Key details:
- window.__shopLocale and window.__shopCurrency are already injected in layout/theme.liquid (after footer section, before closing body tag). configurator.js loads with defer, so these globals are guaranteed to exist at execution time.
- Fallbacks 'de-DE' and 'EUR' protect against edge cases (Theme Editor preview, shopify theme dev) where injection order may vary.
- Intl.NumberFormat with style:'currency' handles symbol placement automatically (€100 vs 100 € vs $100) for all locales — no manual symbol prefix needed.
- Function signature and return type are unchanged (string) — all call sites work as-is.
- Do NOT cache the formatter as a module-level constant — money() is called at most ~15 times per _updatePrice() cycle, instantiation cost is negligible, and caching would miss runtime locale changes.
  </action>
  <verify>
Search configurator.js for any remaining hardcoded 'de-DE' or '€' — must find zero matches. Verify Intl.NumberFormat is used in money(). Verify window.__shopLocale and window.__shopCurrency appear in money().
  </verify>
  <done>money() uses Intl.NumberFormat with window.__shopLocale and window.__shopCurrency, with de-DE/EUR fallbacks. No hardcoded locale or currency symbol in the function.</done>
</task>

<task type="auto">
  <name>Task 2: Replace per-element listeners with delegation in _bindEvents()</name>
  <files>assets/configurator.js</files>
  <action>
Four per-element listeners must be replaced with delegated handling. Make these changes in order:

**A. Add select-variant case to _bindEvents() switch (around line 541, before closing of switch):**

```javascript
case 'select-variant': {
  const group = target.dataset.group;
  const variantArea = target.closest('[data-variant-area]');
  if (variantArea) {
    variantArea.querySelectorAll('.cfg-swatch--selected, .cfg-pill--selected').forEach(s => {
      s.classList.remove('cfg-swatch--selected', 'cfg-pill--selected');
      s.setAttribute('aria-pressed', 'false');
    });
  }
  const selectedClass = target.classList.contains('cfg-swatch') ? 'cfg-swatch--selected' : 'cfg-pill--selected';
  target.classList.add(selectedClass);
  target.setAttribute('aria-pressed', 'true');
  this._selectVariant(group, parseInt(target.dataset.variantId), parseInt(target.dataset.price));
  break;
}
```

This replaces the logic from the per-element listener at line 432-442. The variant items already have `data-action="select-variant"` with `data-group`, `data-variant-id`, `data-price` attributes. The parent `[data-variant-area]` container is used to scope class removal (same as the old `target` variable in _showVariants). `target.closest('[data-variant-area]')` walks up from the clicked swatch/pill to find the area — this works because data-variant-area wraps both swatch and pill containers.

**B. Add select-thumb case to _bindEvents() switch:**

```javascript
case 'select-thumb': {
  const idx = parseInt(target.dataset.thumbIdx);
  this.gallery.querySelectorAll('.cfg-thumb').forEach((t, i) =>
    t.classList.toggle('cfg-thumb--active', i === idx)
  );
  const img = this._galleryImages?.[idx];
  if (img) {
    this._preloadImage(img.src);
    this._setMainImage(img.src);
  }
  break;
}
```

**C. Add edit-summary-step case to _bindEvents() switch:**

```javascript
case 'edit-summary-step': {
  const stepNum = parseInt(target.dataset.editStep, 10);
  this._scrollToStep(stepNum);
  break;
}
```

**D. Remove the per-element listener from _showVariants() (lines 432-442):**

Delete the entire `target.addEventListener('click', ...)` block. The _showVariants() method should end after `this._selectVariant(group, variants[0]?.id, variants[0]?.price);` (line 430).

**E. Modify _updateGallery() (lines 1587-1605):**

1. Add `this._galleryImages = images;` at the start of the method (after the guard check on line 1588). This stores the images array on the instance for the delegated handler to access.

2. Add `data-action="select-thumb"` to each thumb div in the innerHTML template. Change:
```
<div class="cfg-thumb ${i === 0 ? 'cfg-thumb--active' : ''}" data-thumb-idx="${i}"
```
to:
```
<div class="cfg-thumb ${i === 0 ? 'cfg-thumb--active' : ''}" data-action="select-thumb" data-thumb-idx="${i}"
```

3. Delete the entire `this.gallery.addEventListener('click', ...)` block (lines 1597-1604).

**F. Modify summary card in _updateSummary() (line 1243):**

1. Change `data-edit-step` on edit buttons to use `data-action="edit-summary-step"` data-edit-step="${stepNum}". The edit buttons are built earlier in _updateSummary — find where they are created and ensure they have `data-action="edit-summary-step"`.

2. Delete the per-element `card.addEventListener('click', ...)` block (lines 1243-1248).

**G. Remove the direct ctaBtn listener (line 577):**

Delete `this.ctaBtn?.addEventListener('click', () => this._handleAddToCart());`. The main CTA button should already have a `data-action` attribute. Check the Liquid template for the CTA button — if it has `data-action="add-to-cart"` or similar, add a matching case to the switch. If it does not have a data-action, add `data-action="add-to-cart"` to the button in the Liquid template (sections/configurator.liquid) and add:

```javascript
case 'add-to-cart':
  this._handleAddToCart();
  break;
```

Note: `sticky-add-to-cart` case already exists at line 539. The ctaBtn may be a different button (the main CTA vs the sticky one). Check which element `this.ctaBtn` points to in _cacheEls() to determine the correct approach.

**Key anti-pattern reminder:** NEVER add addEventListener inside a method that is called on user interaction. Only _bindEvents() (called once in connectedCallback) may wire events.
  </action>
  <verify>
1. Search configurator.js for `addEventListener` — the only remaining calls should be: (a) `this.addEventListener('click'` in _bindEvents, (b) `this.addEventListener('keydown'` in _bindEvents, (c) `document.addEventListener('DOMContentLoaded'` at the bottom, (d) the `toast.addEventListener('transitionend'` in _showToast (which is fine — it uses `{ once: true }` so it self-cleans).
2. Verify `case 'select-variant':` exists in the switch block.
3. Verify `case 'select-thumb':` exists in the switch block.
4. Verify `data-action="select-thumb"` appears in _updateGallery's innerHTML template.
5. Verify `this._galleryImages = images` exists near the top of _updateGallery().
6. Verify no `target.addEventListener` exists in _showVariants().
7. Verify no `this.gallery.addEventListener` exists in _updateGallery().
  </verify>
  <done>All dynamic child interactions route through _bindEvents() delegated click handler. No per-element listeners accumulate on re-renders. Gallery images stored as this._galleryImages for delegated access. Summary card edit buttons use data-action delegation. CTA button uses delegation.</done>
</task>

<task type="auto">
  <name>Task 3: Implement _calculateLineItems() and wire _updatePrice() and _buildCartItems() to use it</name>
  <files>assets/configurator.js</files>
  <action>
Create a new `_calculateLineItems()` method that extracts the shared price-walking logic from `_updatePrice()` (lines 901-965) and `_buildCartItems()` (lines 1418+), then wire both callers to use it.

**A. Create _calculateLineItems() method:**

Add the method near `_updatePrice()`. It should:

1. Walk `this.state` exactly as `_updatePrice()` currently does to collect all priced items.
2. Return an array of objects: `[{ variantId, quantity, price, properties, label }]`.
3. Include the base product as first item (using `this.state.baseVariantId` and `this.state.basePrice`).
4. Include each add-on/option that has a selected variant with a price (walk the same state keys that `_updatePrice()` currently sums).
5. Use properties matching what `_buildCartItems()` currently assigns (e.g., `{ '_config': 'base' }` for the base, `{ '_config_step': stepLabel }` for add-ons).
6. Include zero-price items only if they have a variantId (needed for cart but contributing $0 to display).

Refer to the Phase 6 research pattern (Pattern 5) for the recommended structure:
```javascript
_calculateLineItems() {
  const items = [];
  // Base product
  if (this.state.baseVariantId) {
    items.push({
      variantId: this.state.baseVariantId,
      quantity: 1,
      price: this.state.basePrice || 0,
      properties: { '_config': 'base' },
      label: 'Base',
    });
  }
  // Walk each step's selected variant from this.state
  // Mirror the exact iteration logic from _updatePrice()
  // ...
  return items;
}
```

Important: Read `_updatePrice()` and `_buildCartItems()` carefully before implementing. The line items must capture every item that EITHER method currently processes. Do not miss items that only one path currently handles — that drift is the bug this task fixes.

**B. Rewrite _updatePrice() to consume _calculateLineItems():**

Replace the price-walking logic in `_updatePrice()` with:
```javascript
_updatePrice() {
  const items = this._calculateLineItems();
  const total = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
  // ... keep existing DOM update logic (setting textContent on price elements)
  this._currentTotal = total;
  this._updateSummary();
}
```

Preserve all DOM update logic (setting price display elements). Only the calculation portion changes — the total computation moves to the shared method.

**C. Rewrite _buildCartItems() to consume _calculateLineItems():**

Replace the item-building logic in `_buildCartItems()` with:
```javascript
_buildCartItems() {
  const configSummary = this._buildConfigSummary();
  return this._calculateLineItems()
    .filter(item => item.variantId)
    .map((item, i) => ({
      id: item.variantId,
      quantity: item.quantity,
      properties: i === 0
        ? { ...item.properties, 'Configuration': configSummary }
        : item.properties,
    }));
}
```

Key detail: The 'Configuration' summary string is attached ONLY to the first item (base product) as a post-processing step in `_buildCartItems()`, not in `_calculateLineItems()`. This preserves the existing cart behavior where only the base line item shows the full config summary in the Shopify cart.

**D. Price updates live on selection:**

Per user decision (locked): price MUST update live on option selection. Verify that all call sites of `_updatePrice()` still trigger immediately on selection (not batched on step advance). The existing call sites (lines 612, 633, 678, 698, 730, 747, 770, 778, 790) should remain unchanged — they already fire on selection.

**Anti-patterns to avoid:**
- Do NOT add regex fallbacks for metafield resolution — if `meta.size` is empty, skip the product.
- Do NOT cache `_calculateLineItems()` results across calls — full recompute on each call is correct (per user decision: simplest approach preferred).
- Do NOT move the Configuration summary property into `_calculateLineItems()` — keep it in `_buildCartItems()` as post-processing.
  </action>
  <verify>
1. Search configurator.js for `_calculateLineItems` — must find the method definition and calls from both `_updatePrice()` and `_buildCartItems()`.
2. Verify `_updatePrice()` no longer independently walks state — it should call `_calculateLineItems()` and reduce the result.
3. Verify `_buildCartItems()` no longer independently walks state — it should call `_calculateLineItems()` and map the result.
4. Verify all existing `_updatePrice()` call sites still exist (lines ~612, 633, 678, 698, 730, 747, 770, 778, 790) — no call site should be removed.
5. Verify the 'Configuration' summary is still attached only to the first cart item in `_buildCartItems()`.
  </verify>
  <done>_calculateLineItems() exists as the single source of truth for line item computation. Both _updatePrice() and _buildCartItems() consume its output. Display total and cart payload are guaranteed to match because they derive from the same data. Price still updates live on option selection.</done>
</task>

</tasks>

<verification>
After all three tasks complete:

1. `money()` — grep for hardcoded 'de-DE' and '€' in configurator.js: zero matches expected (except possibly in Intl.NumberFormat fallback which is acceptable).
2. Event delegation — grep for `addEventListener` in configurator.js: only 3-4 legitimate calls remain (two in _bindEvents for click/keydown, one DOMContentLoaded, one toast transitionend with {once:true}).
3. `_calculateLineItems()` — grep confirms the method exists and is called by both `_updatePrice()` and `_buildCartItems()`. Neither caller independently walks state anymore.
4. All existing switch cases in _bindEvents() remain intact — new cases are additive.
</verification>

<success_criteria>
- money() produces locale-correct formatting using shop globals with de-DE/EUR fallbacks
- _calculateLineItems() is the single source of truth — both _updatePrice() and _buildCartItems() consume it
- Display total and cart payload match exactly for any configuration
- Zero per-element listeners accumulate across re-renders (variant selection, gallery rebuild, summary rebuild)
- All interactive elements in dynamically-rendered content use data-action attributes and route through _bindEvents()
- No functional regression — all 15 configurator steps still work correctly
</success_criteria>

<output>
After completion, create `.planning/phases/07-price-unification-locale-formatting/07-01-SUMMARY.md`
</output>
